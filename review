#!/usr/bin/env bash
set -euo pipefail

function usage {
  cat <<EOF
review [--verbose] [--context TEXT|-] [--help] [git-diff-arguments...]

Ask an LLM to review code changes. This tool passes arguments directly to 'git diff',
allowing you to use any git diff syntax or options.

Options:
  --models LIST      Comma-separated models to run (e.g. "gpt-4o,gemini-2.0-flash")
  -c, --context TEXT  Add additional context for the review, appended to the system prompt. Will be concatenated if provided multiple times
      --context -     Read additional context from stdin
  -h, --help          Show this help message
  -v, --verbose       Enable verbose output

Review Examples:
  # Review unstaged changes
  review

  # Review with additional context
  review --context "Focus your review on possible authentication bypasses"

  # Review with context from stdin
  cat PR_DESCRIPTION.md | review --context -

  # Review with context from a command
  git log -1 --pretty=%B | review --context -

  # Review staged changes
  review --cached

  # Review changes between HEAD and main
  review main

  # Review changes between two branches
  review main feature-branch
  # OR
  review main..feature-branch

  # Review only changes since branch diverged from main
  review main...feature-branch

  # Review a remote branch
  review origin/main..origin/feature-branch

  # Limit review to specific files
  review main -- src/components/

  # Adjust context lines
  review -U5 main

Dot Notation:
  - Two dots (A..B): Direct comparison between A and B
  - Three dots (A...B): Compare common ancestor of A and B with B

Depends on:
- llm: https://github.com/simonw/llm
- bat: https://github.com/sharkdp/bat (optional)
EOF
  exit "${1:-0}"
}

git_args=()
has_unified_context=false
context_value=10
additional_context=""

# Allow multiple models via flag or env
models_arg="${LLM_MODELS:-}"   # e.g. export LLM_MODELS="gpt-4o,gemini-2.0-flash"
models_list=()

# Process only our custom arguments, pass everything else to git
while [[ $# -gt 0 ]]; do
  case "$1" in
    -v|--verbose)
      set -x
      shift
      ;;
    --models)
      shift
      if [[ $# -gt 0 ]]; then
        models_arg="$1"
        shift
      else
        error "Missing value for --models (expected comma-separated list)"
      fi
      ;;
    -c|--context)
      shift
      if [[ $# -gt 0 ]]; then
        # Read from stdin for context
        if [[ "$1" == "-" ]]; then
          if [[ -t 0 ]]; then
            error "No stdin input available for --context -"
          fi
          new_context=$(cat)
          if [[ -z "$new_context" ]]; then
            error "Empty input from stdin for --context -"
          fi
        else
          new_context=$1
        fi
        if [[ -n "$additional_context" ]]; then
          additional_context="${additional_context}

$new_context"
        else
          additional_context="$new_context"
        fi
        shift
      else
        error "Missing value for --context option"
      fi
      ;;
    -U[0-9]*)
      # Form: -U10
      has_unified_context=true
      context_value="${1#-U}"
      git_args+=("$1")
      shift
      ;;
    -U)
      # Form: -U 10
      has_unified_context=true
      shift
      if [[ $# -gt 0 && "$1" =~ ^[0-9]+$ ]]; then
        context_value="$1"
        # normalize to `-U10` to ease our checking later on
        git_args+=("-U$1")
        shift
      else
        error "Missing value for -U option"
      fi
      ;;
    --unified=*)
      # Form: --unified=10
      has_unified_context=true
      context_value="${1#--unified=}"
      git_args+=("$1")
      shift
      ;;
    -h|--help)
      usage
      ;;
    *)
      # Store all other arguments to pass to git diff
      git_args+=("$1")
      shift
      ;;
  esac
done

# Split models list after parsing
if [[ -n "$models_arg" ]]; then
  IFS=',' read -r -a models_list <<< "$models_arg"
fi

readonly RED='\033[0;31m'
readonly BLUE='\033[0;34m'
readonly RESET='\033[0m'

info() {
  printf "${BLUE}• %s${RESET}\n" "$1" >&2
}

error() {
  printf "${RED}❌ %s${RESET}\n" "$1" >&2
  usage 1
}

if ! command -v llm >/dev/null 2>&1; then
  error "Missing required command llm. On mac: brew install llm"
fi

# Default unified context if none specified.
if [[ "$has_unified_context" == false ]]; then
  git_args=("-U$context_value" "${git_args[@]}")
fi

# Run git diff
diff_output=$(git diff "${git_args[@]}" 2>/dev/null || error "Git diff command failed. Check your arguments.")

if [[ -z "$diff_output" ]]; then
  error "No changes found to review."
fi

# Token estimation to avoid huge diffs
max_tokens=50000
chars_per_token=4
char_count=${#diff_output}
estimated_tokens=$((char_count / chars_per_token))

if [[ $estimated_tokens -gt $max_tokens ]]; then
  reduced_context=$((context_value * max_tokens / estimated_tokens))
  reduced_context=$((reduced_context > 0 ? reduced_context : 1))
  info "Reducing context to $reduced_context lines to fit token limits"

  new_git_args=()
  for arg in "${git_args[@]}"; do
    if [[ "$arg" =~ ^-U[0-9]+$ ]]; then
      new_git_args+=("-U$reduced_context")
    elif [[ "$arg" =~ ^--unified=[0-9]+$ ]]; then
      new_git_args+=("--unified=$reduced_context")
    else
      new_git_args+=("$arg")
    fi
  done

  if [[ $((${#diff_output} / chars_per_token)) -gt max_tokens ]]; then
    error "Diff is too large to process even with minimal context. Try reviewing a smaller set of changes."
  fi

  diff_output=$(git diff "${new_git_args[@]}" 2>/dev/null || error "Git diff command failed with reduced context.")
fi

prompt="You are a staff-level engineer performing a pull request review from a Git diff.
Respond in **Markdown**, be concise and actionable.

## Scoring rubric (5 stars, weighted)
Rate using these weights (total 100%):
- Correctness & Bugs (40%)
- Security & Privacy (5%)
- Maintainability & Readability (20%)
- Performance (15%)
- API/UX & Compatibility (10%)
- Documentation & DX (5%)
- Scope & Risk (5%)

Star meanings:
★★★★★ Excellent (merge as-is)
★★★★☆ Solid (minor fixes)
★★★☆☆ Needs changes
★★☆☆☆ Not ready
★☆☆☆☆ Broken/unsafe

**Important:** This repository has no automated tests. In the **“Test plan gaps”** section,
call out what to verify, but **do not deduct from the star rating** for missing tests here.
Only reduce score if this PR actively reduces testability or obviously breaks behavior.

Compute a **weighted score (0–100)**, then map to stars:
- 90–100 → ★★★★★
- 75–89  → ★★★★☆
- 60–74  → ★★★☆☆
- 40–59  → ★★☆☆☆
- 0–39   → ★☆☆☆☆

## What to do
1) Read the diff and identify risks and mistakes.
2) Reference files and lines when helpful (quote minimal snippets).
3) Prefer specific, low-risk fixes and examples.
4) If something is ambiguous, state an assumption.

## Output format (use these exact headings)
### Summary (2–4 sentences)
Concise description of what changed and the risk profile.

### Stars & Score
Overall: **X/5 (★★★★★/★★★★☆/… ) – SCORE/100**
- Correctness & Bugs – NN/100
- Security & Privacy – NN/100
- Maintainability & Readability – NN/100
- Performance – NN/100
- API/UX & Compatibility – NN/100
- Documentation & DX – NN/100
- Scope & Risk – NN/100

### Blocking issues (must-fix)
- [file:line] Problem → Specific fix or example patch
- …

### Non-blocking suggestions
- [file:line] Improvement → Rationale / tiny patch if helpful
- …

### Security & Privacy highlights
- Note any auth, data exposure, injection, secrets, or PII handling concerns.

### Test plan gaps (do NOT affect stars)
- What to manually verify or quick checks to run.
- Minimal tests that would add confidence (if this repo had tests).

### Suggested commit messages (optional)
- Short, imperative suggestions that make the history clearer.

Keep it under ~700–900 words. Avoid repeating large chunks of the diff.
PROMPT
# --- End replacement ---"

# Add the additional context if provided
if [[ -n "$additional_context" ]]; then
  prompt="$prompt

## Additional Context
$additional_context"
fi

# Helper to run one model
run_for_model() {
  local model="$1"
  if command -v bat >/dev/null 2>&1; then
    printf "## %s\n\n" "$model" | bat --paging=never --style=plain --language=markdown
    echo "$diff_output" | llm -s "$prompt" -m "$model" | bat --paging=never --style=plain --language=markdown
  else
    printf "## %s\n\n" "$model"
    echo "$diff_output" | llm -s "$prompt" -m "$model"
  fi
}

exit_status=0

if [[ ${#models_list[@]} -gt 0 ]]; then
  for model in "${models_list[@]}"; do
    run_for_model "$model" || exit_status=1
    echo -e "\n---\n"
  done
else
  if [[ -n "${LLM_MODEL:-}" ]]; then
    if command -v bat >/dev/null 2>&1; then
      echo "$diff_output" | llm -s "$prompt" -m "$LLM_MODEL" | bat --paging=never --style=plain --language=markdown
    else
      echo "$diff_output" | llm -s "$prompt" -m "$LLM_MODEL"
    fi
  else
    if command -v bat >/dev/null 2>&1; then
      echo "$diff_output" | llm -s "$prompt" | bat --paging=never --style=plain --language=markdown
    else
      echo "$diff_output" | llm -s "$prompt"
    fi
  fi
  exit_status=${PIPESTATUS[1]:-0}
fi

if [[ "$exit_status" -eq 130 ]]; then
  exit 130
elif [[ "$exit_status" -ne 0 ]]; then
  echo "Error: LLM command failed." >&2
  exit 1
fi
